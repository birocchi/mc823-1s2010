% Exemplo de relatório técnico do IC
% Criado por P.J.de Rezende antes do Alvorecer da História.
% Modificado em 97-06-15 e 01-02-26 por J.Stolfi.
% Last edited on 2003-06-07 21:12:18 by stolfi

% modificado em 1o. de outubro de 2008

\documentclass[11pt,twoside]{article}
\usepackage{techrep-ic}
\usepackage[pdftex]{graphicx}
\usepackage{enumerate}

%%% SE USAR INGLÊS, TROQUE AS ATIVAÇÕES DOS DOIS COMANDOS A SEGUIR:
\usepackage[brazil]{babel}
%% \usepackage[english]{babel}

%%% SE USAR CODIFICAÇÃO LATIN1, TROQUE AS ATIVAÇÕES DOS DOIS COMANDOS A
%%% SEGUIR:
%% \usepackage[latin1]{inputenc}
\usepackage[utf8]{inputenc}

\begin{document}

%%% PÁGINA DE CAPA %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Número do relatório
\TRNumber{45}

% DATA DE PUBLICAÇÃO (PARA A CAPA)
%
\TRYear{10} % Dois dígitos apenas
\TRMonth{05} % Numérico, 01-12

% LISTA DE AUTORES PARA CAPA (sem afiliações).
\TRAuthor{Birocchi, Anderson - RA: 072787 \and Braga, Felipe - RA:070803}

% TÍTULO PARA A CAPA (use \\ para forçar quebras de linha).
\TRTitle{MC823 - Laboratório de Redes\\Projeto 2: Servidor UDP Iterativo para Consulta a Banco de Dados de um Cinema}

\TRMakeCover

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% O que segue é apenas uma sugestão - sinta-se à vontade para
% usar seu formato predileto, desde que as margens tenham pelo
% menos 25mm nos quatro lados, e o tamanho do fonte seja pelo menos
% 11pt. Certifique-se também de que o título e lista de autores
% estão reproduzidos na íntegra na página 1, a primeira depois da
% página de capa.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Nomes de autores ABREVIADOS e titulo ABREVIADO,
% para cabeçalhos em cada página.
%
\markboth{Birocchi, Braga}{MC823 - Projeto 2, Aplicação UDP}
\pagestyle{myheadings}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TÍTULO e NOMES DOS AUTORES, completos, para a página 1.
% Use "\\" para quebrar linhas, "\and" para separar autores.
%
\title{MC823 - Projeto 2, Servidor UDP Iterativo para Consulta a Banco de Dados de um Cinema}

\author{Anderson Birocchi, Felipe Braga}

\date{}

\newpage
\tableofcontents
\newpage

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newenvironment{codelisting}
{\begin{list}{}{
\setlength{\leftmargin}{1em}
}
\item\scriptsize\bfseries}{\end{list}}


\begin{abstract}
Complementarmente ao anterior, o objetivo deste projeto é dar uma noção dos aspectos da implementação de um sistema que utiliza comunicação em rede. Desta vez, no entanto, foi usado o protocolo da camada de transporte UDP - \textit{User Datagram Protocol}. Procurou-se verificar as brechas geradas pela inconfiabilidade na entrega deste protocolo, assim como comparar a aplicação com a anterior, em TCP (tanto com relação à implementação como ao desempenho).
\end{abstract}

\section{Introdução}

Vimos no projeto anterior que os sockets TCP são ótimos para atividades que requerem robustez e segurança, como transações bancárias, armazenamento remoto de dados, transferência de arquivos em geral, etc. Porém, em troca dessa robustez e segurança, a velocidade da transmissão é prejudicada, já que no protocolo TCP há controle de fluxo, controle de congestionamento da rede e tratamento de perda de pacotes. Isso não costuma ser um problemas para as atividades citadas anteriormente, pois a velocidade não é algo crucial, no entanto, e se a atividade for uma transmissão ao vivo pela internet? A velocidade é fundamental, e a perda de alguns pacotes não condenam totalmente a transmissão.\\
Para esse e muitos outros casos, são utilizados sockets UDP, com comunicação sem conexão, apenas através de datagramas, que por não ter nenhum tipo de controle de fluxo, congestionamento ou perda de pacotes, consegue uma transmissão rápida porém não confiável de datagramas.\\
E se utilizarmos sockets UDP para o servidor de banco de dados de um cinema já implementado anteriormente? Será que a velocidade de comunicação realmente vai aumentar? Será que a perda de pacotes vai inviabilizar o uso da aplicação?\\
Nosso projeto irá reimplementar o servidor para consultas em bancos de dados de um cinema, mas agora utilizando sockets UDP na comunicação entre o servidor e o cliente.\\
A seção 2 irá especificar novamente o que exatamente o programa deve fazer; a seção 3 irá comentar mais detalhadamente a implementação, as definições, suposições tomadas e ferramentas utilizadas; a seção 4 irá analisar o desempenho da aplicação atraveś de várias medidas de tempo e também uma comparação dos tempos se utilizando TCP e UDP; a seção 5 irá mostrar quão não-confiável inconsistente é a aplicação se utilizando UDP; na seção 6 encontra-se uma breve conclusão sobre o projeto e, por último, na seção 6 estará o código fonte necessário para compilar e executar o servidor e o cliente.


\section{Casos de Uso}

Relembrando o que a aplicação deve fazer, segue abaixo uma listagem de 6 ações que serão implementadas. Nota: as ações com (*) precisam receber um identificador numérico do filme como entrada.\\
As ações sempre serão tomadas pelo cliente, sendo o servidor apenas quem irá processar o pedido. O resultado da ação apenas é vista pelo cliente que a iniciou, deixando o servidor totalmente à parte do que está acontecendo do lado dos seus clientes.
\subsection{Listar todas as informações de todos os filmes}
Mostrar o ID, título, sinopse, horário das sessões e as salas de todos os filmes cadastrados no banco de dados do servidor.
\subsection{Listar ID e título de todos os filmes}
Fazer uma busca rápida de todos os títulos e seus IDs, mais utilizado para auxiliar em futuras consultas, e utilização dos próximos casos de uso.
\subsection{Listar todas as informações de um filme (*)}
Buscar todas as informações sobre o filme com o dado ID.
\subsection{Mostrar a sinopse de um filme (*)}
Mostrar a sinopse completa do filme com o dado ID.
\subsection{Mostrar a avaliação de um filme (*)}
Mostrar a quantidade de votos o filme teve e qual foi a pontuação obtida.
\subsection{Avaliar um filme (*)}
Dar uma pontuação ao filme com o dado ID.



\section{Implementação}
\subsection{Protocolo de comunicação usando UDP}
Como o UDP não garante que os dados enviados serão recebidos, e se recebidos, podem chegar fora de ordem, foram implementada duas principais medidas para reger a comunicação:
\subsubsection{Do cliente para o servidor}
Anteriormente, com o uso do TCP, o cliente selecionava a opção, que era enviada ao servidor. No caso de se tratar de uma opção que requer um id, o cliente então lê e envia este id, enquanto no lado servidor a thread responsável por aquela conexão espera este id. O mesmo acontecia para a opção 6, que requer uma nota para avaliar o filme.\\
Como não há uma conexão de fato, seria pouco seguro continuar usando esta abordagem, uma vez que um cliente C1 poderia enviar uma opção que requer um id; e quando o servidor passasse a esperar pelo id, outro cliente C2 poderia enviar uma opção (que seria lida como id), e o programa ficaria inconsistente.\\
É possível pensar na comunicação do cliente com o servidor como uma pergunta e resposta, onde o cliente envia uma pergunta "atômica" (apenas um datagrama), de modo que o servidor sabe exatamente o que o cliente quer com apenas uma mensagem.\\
Para isso, foram empacotadas as informações: \textit{opção}, \textit{id} e \textit{nota} num vetor chamado \textit{request}, mesmo para as opções que não requerem id e/ou nota. O envio deste vetor é, então, a considerada pergunta "atômica" e suficiente.
\subsubsection{Do servidor para o cliente}
Depois de enviar uma pergunta ao servidor, o cliente passa a esperar pela resposta. Mas e se a resposta começar a demorar? O UDP não garante que as mensagens enviadas serão recebidas. Logo, tanto a pergunta como a resposta podem se perder. Assim, no caso de um ou outro, o cliente ficaria bloqueado infinitamente no \textit{recv()}, o que não é interessante.\\
Para contornar isso, implementamos um \textit{time-out} para o recebimento de respostas pelo cliente. Seu funcionamento se dá como segue:\\
\textbf{Ideia 1}\\
Toda vez que o cliente for receber uma resposta do servidor, entra num laço \textit{for()}, razoavelmente grande (por exemplo, de 1000 vezes). A cada iteração, é chamado o \textit{recv()} no modo não-bloqueante (a partir da configuração pela flag). Caso esse \textit{recv()} leia a resposta, sai do laço e sabe-se que nenhuma msg se perdeu. Caso contrário, é chamada uma função de espera \textit{sleep()}, de algum tempo curto (p.e, 100 micro-segundos) e terminado isso, volta ao início do laço. Caso o laço se encerre, sabe-se que a resposta não chegou até o \textit{time-out} e provavelmente ou a pergunta ou a resposta se perdeu.\\
No entanto, ao tentarmos efetuar a implementação, surgiram alguns problemas para conseguir fazer com o que o \textit{recv()} ficasse efetivamente não bloqueante. Tentou-se mudar todo o socket do cliente para não bloqueante, com a função \textit{fcntl()}, que também se mostrou ineficiente. Somado ao fato de este ser um método que faz o processo cliente ficar em espera ocupada (consumindo recursos do processador), optamos por implementar usando a função \textit{select()}.
\textbf{Ideia 2}\\
Dando uma grande facilidade, a função \textit{select()} implementa tanto um "ouvinte" para o socket de leitura, retornando quando algum datagrama chegou até ele, como o \textit{time-out}, tornando a codificação bem mais simples.\\


O sistema é desenvolvido na linguagem C, utiliza as bibliotecas de sockets TCP para fazer a comunicação pela rede, gerencia as várias conexões com threads da biblioteca pthreads.h e faz controle de exclusão mútua através de semáforos da biblioteca semaphore.h.\\
Primeiramente vamos explicar como foi implementado o banco de dados e suas operações, e depois explicar como é feita a comunicação entre o servidor e o cliente, qual protocolo seguem, como são distribuídas as conexões entre as threads e quando e como são criadas.\\
Basicamente, o funcionamento do sistema é: o servidor fica em um laço infinito, aguardando requisições de conexão; o cliente estabelece essa conexão; inicia-se uma sequencia de requisições do cliente e respostas por parte do servidor; cliente encerra o uso.\\

No fim, a quantidade de linhas de código de todos os arquivos do sistema (*.c e *.h) é 1461, o que já não é um programa simples, porém ainda está longe de ser uma grande aplicação.\\

Para organizar a discussão sobre a implementação, vamos tratar de tópicos separamente.\\

\subsection{Dados}
\subsubsection{Armazenamento (banco de dados)}
Ao invés de usar um sistema de gerenciamento de banco de dados (SGDB) optamos, pela praticidade, armazenar todos os nossos dados em um arquivo de texto puro chamado "filmes.dat" onde os campos que contém os atributos de um filme são separados pelo caractere '@' . Um registro da base de dados tem o seguinte formato:\\
\textit{tamanho do registro@ID@avaliações@média@título@sinopse@sala@horários@}\\
Com relação aos tipos dos dados, \textit{tamanho do registro} e \textit{ID} são numéricos, inteiros, de tamanho variável com limites de 1024 para o primeiro e $10^{20}$ - 1 para o segundo. Vale ressaltar que estes são os dois únicos campos de tamanho fixo da representação, com 4 dígitos para o primeiro e 6 (incluindo o ponto decimal) para o segundo.\\
\textit{Número de avaliações} e \textit{média} são numéricos, com o primeiro inteiro até 9999 e o segundo, ponto flutuante de 0 a 999, com duas casas decimais (000.00 a 999.99).\\
\textit{Título} (30), \textit{Sinopse} (900), \textit{Sala} (20) e \textit{Horários} (20) são cadeias de caracteres (\textit{strings}), com seus respectivos tamanhos citados.\\
Segue um exemplo de uma entrada no banco de dados:\\
\textit{279@1@0000@000.00@Rei Leão@Sinopse do filme@sala10@10h, 12h30, 15h@}\\
Nota: Para facilitar a inserção de novos filmes no sistema, foi feito um script (add\_filme.sh) que pode ser visto na seção 7.1.
\subsubsection{Estruturas de dados}
Existem duas formas básicas de como os dados de um filme são representados em memória: como uma cadeia crua de caracteres e como uma estrutura chamada \textbf{filme}.\\
A primeira opção, mais simples, é usada na extração dos dados do arquivo e na transmissão destes pela rede.\\
Já a segunda, agrega as informações de forma mais coerente, facilitando a implementação de funções que precisam acessar os dados de um filme para, por exemplo, imprimi-los na tela. A definição desta estrutura pode ser vista no arquivo data\_access.h (biblioteca de especificações sobre o acesso aos dados), localizado na seção 7.2.\\

\subsection{Comunicação Cliente-Servidor}
Todas as funcionalidades aqui descritas encontram-se especificadas no arquivo internet.h (7.4) e implementadas em internet.c (7.5).\\
A fim de facilitar a utilização das funções de envio e recebimento de informações, foram implementadas as funções \textit{socket\_push\_char()}, \textit{socket\_pop\_char()}, \textit{socket\_push\_buffer()} e \textit{socket\_pop\_buffer()}. As duas primeiras se encarregam de enviar para e retirar da conexão com o socket, um único caractere. Como trabalhamos com tamanhos variáveis de atributos, é bastante útil comparar cada caractere lido da stream antes de fazer a próxima leitura.\\
Já as outras duas, uma envia outra recebe um buffer, uma cadeia de caracteres da conexão. Mais útil e eficiente para transportar grandes lotes de informações de uma só vez.\\
Analisando o número de \textit{send()}s e \textit{recv()}s, certamente a comunicação caractere por caractere é muito despendiosa, pois cada mensagem de 1 byte é empacotada e enviada às camadas mais baixas da rede. Certamente essa não foi a melhor escolha possível, mas facilitou em grande parte o trabalho de verificação do fim de cada atributo.

%% !! Não é mais necessário se ter exclusão mútua !! %%
%
%\subsection{Concorrência}
%A despeito da referência do Beej's, decidimos por implementar a concorrência através do uso de threads, e fomos muito felizes nessa decisão. A implementação está dentro do arquivo server.c, na seção 7.7.\\
%Dentro do main() do servidor, existe um laço infinito, cuja responsabilidade é, ao chegar uma nova conexão, alocar uma thread disponível para tratá-la (através da função trata\_thread()). O controle das threads disponíveis é feito através de um vetor global available\_thrs[].\\
%A partir de impressões de mensagens na saída padrão, é possível verificar facilmente o comportamento multi-usuário do servidor. Além de aceitar conexões simultâneas, pode-se forçar mais conexões do que o disponível, o que faz com que o servidor recuse a conexão. Se o cliente quiser tentar mais uma vez posteriormente, ele pode.

\subsection{Concorrência e Exclusão Mútua}

%%Falar que naum eh mais necessario, por que o servidor eh iterativo e naum regido à conexão, que não tem como saber de quem vem o pacote%%
Decidimos implementar a funcionalidade de avaliação de filme no nosso projeto, o que implicou na necessidade de prover uma maneira segura de garantir que threads concorrentes não fariam escritas no arquivo de modo inconsistente.\\
O cenário de inconsistência é o seguinte: a thread T1 lê o número de avaliações N0 e média M0 do arquivo e processa novos valores N1 e M1 a partir da avaliação do cliente. Então, antes de T1 atualizar os dados no arquivo, a thread T2 lê N0 e M0 arquivo e calcula seus valores N2 e M2. Aconteça o que acontecer, os dados estarão inconsistentes, pois as operações não estarão sendo cumulativas, como espera-se que sejam.\\
O meio de implementação da exclusão mútua entre as threads foi utilizando semáforos, conforme pode-se ver em server.c (7.7).\\
Como todas as threads funcionam com a mesma função, e foi possível fazer a separação clara entre cada caso de uso, foi simples estabelecer a região crítica (que não pode nunca ser executada por mais de uma thread ao mesmo tempo).\\
Além disso, sendo o caso de escrita concorrente em arquivo, o semáforo é iniciado com o valor 1, permitindo que apenas uma thread possa utilizar o recurso de cada vez.


\section{Análise de Tempo}
Para a análise de tempo, foram consideradas duas operações a serem analisadas: tempo de comunicação (RTT) e consulta ao servidor.\\
Para se obter uma boa precisão, foi utilizada a função "gettimeofday", que tem a precisão em microsegundos, o que já é boa o suficiente para nossa aplicação. A função pega o tempo atual em que foi chamada, portanto, para calcular o tempo de alguma operação, basta calcular o tempo antes e depois da operação e calcular a diferença entre eles.\\
Foram usadas duas configurações:\\
\textbf{Configuração 1: }Dois computadores presentes na mesma sub-rede (SIFEEC).\\
IP local: 143.106.150.77\\
IP remoto: 143.106.150.74\\
\textbf{Configuração 2: }Um computador no laboratório do IC3 e outro no SIFEEC.\\
IP local: 143.106.150.77\\
IP remoto: 143.106.16.163 (xaveco)\\
\begin{verbatim}
[ra072787@xaveco ~]$ traceroute 143.106.150.74
traceroute to 143.106.150.74 (143.106.150.74), 30 hops max, 60 byte packets
 1  routeric3.lab.ic.unicamp.br (143.106.16.148)  2.801 ms  5.398 ms  7.873 ms
 2  143.106.16.150 (143.106.16.150)  0.099 ms  0.074 ms  0.065 ms
 3  143.106.7.129 (143.106.7.129)  0.218 ms  0.182 ms  0.159 ms
 4  area3-gw.unicamp.br (143.106.1.129)  0.570 ms  0.748 ms  0.981 ms
 5  ptp-nct-nbs.unicamp.br (143.106.199.13)  0.636 ms  0.870 ms  1.036 ms
 6  fee-gw.unicamp.br (143.106.1.10)  1.049 ms  1.332 ms  1.305 ms
 7  le20-10.grad.fee.unicamp.br (143.106.150.74)  2.070 ms  2.047 ms  2.401 ms
[ra072787@xaveco ~]$
\end{verbatim}
\textit{Observação: }Todos os tempos que serão mostrados nas próximas seções estão em micro-segundos, e pode-se verificar todos os valores encontrados na seção de Anexos.\\

\subsection{Tempo de Comunicação - RTT}
Tempo decorrido entre o cliente chamar a função para conectar ao servidor e a resposta deste.\\
\textbf{Configuração 1: }\\
Média do tempo de RTT: \textbf{274,16 us}\\
Desvio padrão: \textbf{10,72 us}\\
\textbf{Configuração 2: }\\
Média do tempo de RTT: \textbf{1601,7 us}\\
Desvio padrão: \textbf{1697,68 us}\\
%\begin{figure}[htb]
%  \centering
%  \includegraphics[width=15cm]{rtt.png} 
%  \caption{Representação das medições para o RTT.}
%  \label{fig:rtt}
%\end{figure}

\subsection{Tempo de Consulta}
Tempo decorrido entre o cliente realizar o caso de uso 1 (consulta completa de todos os filmes do banco de dados).\\
\textbf{Configuração 1: }\\
Média do tempo de RTT: \textbf{1769,16 us}\\
Desvio padrão: \textbf{432,29 us}\\
\textbf{Configuração 2: }\\
Média do tempo de RTT: \textbf{9390,89 us}\\
Desvio padrão: \textbf{9758,98 us}\\
%\begin{figure}[htb]
%  \centering
%  \includegraphics[width=15cm]{consulta.png} 
%  \caption{Representação das medições para a consulta.}
%  \label{fig:rtt}
%\end{figure}


Pode-se verificar a diferença considerável entre os tempos de RTT para as duas configurações. Obviamente, o tempo para abertura da conexão foi maior para a segunda 
configuração, já que os pacotes devem ser transmitidos através de roteadores e enlaces adicionais, como mostrado no resultado do traceroute acima.\\
De modo a comprovar a influência do tráfego na rede, é visível a grande diferença entre os desvios padrão em porcentagem com relação ao valor absoluto.\\


\section{Confiabilidade e Consistência}
Dois pontos a considerar: robustez quanto à comunicação e consistência dos dados.\\
Tentamos fazer todas as verificações de erros possíveis nas funções das bibliotecas de comunicação com o socket, tanto no lado cliente como no servidor. Ainda assim, não conseguimos implementar um importante caso de exceção: notificar e encerrar o cliente quando o servidor "cai".\\
Com relação à consistência dos dados, esta é garantida pela exclusão mútua nas operações de atualização de avaliação.

\section{Conclusão}
Podemos considerar que a aplicação já está totalmente funcional, todas as consultas estão funcionando corretamente, há a garantia da consistência do banco de dados do cinema e a comunicação entre cliente e servidor está boa, exceto no caso em que o servidor cai, deixando o cliente esperando por uma resposta.\\
Por utilizar o protocolo TCP, a comunicação possui todas as suas vantagens, como confiabilidade na transferência de pacotes, controle de fluxo e controle de congestionamento, o que garante uma qualidade maior à aplicação.\\
A análise de tempo também cumpriu com as espectativas, tendo uma média e um desvio padrão mais baixo para redes próximas e valores mais altos para redes mais distantes.\\
Ao fazer a aplicação em C, o nível de abstração não foi muito alto, pois tivemos que tratar muitos detalhes das conexões.\\
Podemos dizer também que fomos felizes ao utilizar um controle de conexões por threads, pois fica mais fácil de controlar do que com processos, já que quando o processo principal termina, todas as threads também terminam, evitando assim processos zumbi, além de ser mais fácil se implementar exclusão mútua de threads, por exemplo, com semáforos ou mutex lock.\\
Nosso servidor de banco de dados de cinema ainda não é um sistema completo e bem acabado, mas já provê uma base sólida para implementar aplicações gráficas e de maior porte, utilizando o servidor como o núcleo da aplicação. Pretendemos, em versões posteriores, melhorar o programa, resolver bugs e talvez, utilizar uma biblioteca gráfica para tornar sua interface mais usável. 

\section{Código Fonte}



%\section{Anexo}
%\begin{figure}[htb]
%  \centering
%  \includegraphics[width=15cm]{medicoes.png} 
%  \caption{Representação das medições para a consulta.}
%  \label{fig:rtt}
%\end{figure}

\begin{thebibliography}{99}
\bibitem{R1} HALL, Brian. Beej's Guide to Network Programming. Disponível em: http://http://beej.us/guide/bgnet/output/html/multipage/index.html.
\end{thebibliography}

\end{document}
